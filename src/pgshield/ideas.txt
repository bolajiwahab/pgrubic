**** important **********
- getting stmt_location should be robust
- merge get line details and set locations
- fix documentations for unsafe
- write more fixes
**********

- maybe we should also check for schema name at alter statements?

# building locally probably with make
- python3 -m build
- pip install dist/pgshield-*.tar.gz

- id int GENERATED ALWAYS AS (1) STORED UNIQUE -- will allow only one row
1. You realize of course that an index on a constant is pretty
 Tom> useless. I wonder if we should disallow that. Not needed as there are
several ways to define an index that probably or definitely results in
a useless index - maybe we can enforce this still
1. table with 0 defined columns. No need really, no mention anywhere online.
2. single letter column, table or identifier?

# get codes from file name instead, update name to groups
or maybe we can group rules per paths and then we can get the group from the path

# cyclic references A -> B, B -> A

# set line length and remove # noqa: E501

RULES
1. concurrently should not be a transaction block
2. Check there is an index on a foreign key column
- register foreign key columns
- register indexes 
But how do we guarantee this is only checked at the end of the whole rules

4. Check for dropping of unique index no possiblre as dont have access to the catalog.
5. Check for duplicate indexes - we use memory here?


# is it possible to build a cache of nullable columns with their tables 
# and then count, if greater than 1, report
# can we do same for foreign keys to check they are indexed

#### parsed_tree, tokenized_tree then we supply to respective callers such as noqa, identifier checks such as length

# discard names from rules and leave code, we can generate the rule name 
# from the class name, leaving it can lead to duplication and mistakes.
# less code, less bug, less maintenance
# we need to keep the groups e.g unsafe, convention
# also ensure we validate them against known groups
# missing rule number

# prevent missing rule numbers

##### finish up with fixes tomorrow
# ensure code and name are typed in all classes
# found commented code, any statement that ends with ; and commented
# we need to rename few classes

# fix gap_in_range_partition_bound
# partition schema ?
# split schemas into type and schema


**********************
We do not support custom schema qualified types
****************
# column that has date should be typed date?
# column that has at should be typed timestamptz?

# "[a-zA-Z0-9]+__[a-zA-Z0-9]+__[0-9]{4}_[0-9]{2}(?:_[0-9]{2})?$"


# we cannot use format {table}_{columns(s)}_idx because postgres only allow 63 characters by default in identifiers
# e.g in indexname where we are expecting table name and column name, if postgres truncates the identifier
# then our checks will be flawed, best effort is to use regex to ensure format but no further checks on table
# and column name
# columns: str = ("_").join(stream.RawStream()(node.indexParams).split("; "))

-- include-convention as an arg (if your service is compliant then enable this to prevent future uncompliance hence no need)
enable once service is rfc compliant
-- mode -- strict/changed -- strict scans all source files, changed uses git to get changed files

-- update : enable convention by default with default config, since we are following postgres normal conventions
-- best practices, people can disable convention by default

-- Don't use CURRENT_TIME

-- schema-qualified custom type

--*** turn everything into keywords args

-- schemas.partitions []
-- schemas.tables[] -- not supported

[
    "test": {
        "key": {
            "name": "created",
            "type": "timestamp"
        },
        "resolution: "day"|"month,
        -> day -> 1 year, month -> 2 years
    },
]


/unsafe/table
       /column
       /constraint
       /index
       /
       /
       /
       /


"""Convention for partitioning."""

import abc
import typing
from datetime import datetime

from pglast import ast, enums
from dateutil import relativedelta

from pgshield.core import linter


class GapInRangePartitionBound(linter.Checker):
    """Gap in range partition bound."""

    name = "convention.gap_in_range_partition_bound"
    code = "CVP001"

    is_auto_fixable: bool = False

    def visit_PartitionBoundSpec(
        self,
        ancestors: ast.Node,
        node: ast.PartitionBoundSpec,
    ) -> None:
        """Visit PartitionBoundSpec."""
        partitioning_resolution: list[int] = []

        statement: linter.Statement = linter.get_statement_details(ancestors)

        if (
            not node.is_default
            and node.strategy == enums.PartitionStrategy.PARTITION_STRATEGY_RANGE
        ):

            # get the difference in hours, days, months, years
            lower_bound = datetime.fromisoformat(node.lowerdatums[-1].val.sval)
            upper_bound = datetime.fromisoformat(node.upperdatums[-1].val.sval)

            # ensure we only have of days, months, years, hours, weeks in the difference
            # e.g. (months=+1, days=+1)

            difference_in_hours = relativedelta.relativedelta(
                upper_bound,
                lower_bound,
            ).hours

            difference_in_days = relativedelta.relativedelta(
                upper_bound,
                lower_bound,
            ).days

            difference_in_weeks = relativedelta.relativedelta(
                upper_bound,
                lower_bound,
            ).weeks

            difference_in_months = relativedelta.relativedelta(
                upper_bound,
                lower_bound,
            ).months

            difference_in_years = relativedelta.relativedelta(
                upper_bound,
                lower_bound,
            ).years

            partitioning_resolution.append(difference_in_hours)
            partitioning_resolution.append(difference_in_days)
            partitioning_resolution.append(difference_in_weeks)
            partitioning_resolution.append(difference_in_months)
            partitioning_resolution.append(difference_in_years)

            # check if any resolution is not 1
            if all(resolution != 1 for resolution in partitioning_resolution):

                self.violations.append(
                    linter.Violation(
                        lineno=statement.location,
                        column_offset=linter.get_node_location(node),
                        statement=ancestors[statement],
                        description="Gap in range partition bound",
                    ),
                )


class _PartitionSpec(abc.ABC, linter.Checker):
    """Base class for PartitionSpec."""

    # To be overridden by subclasses
    name = ""
    code = ""

    @abc.abstractmethod
    def _check_partition_spec(
        self,
        *,
        partition_spec: ast.PartitionSpec,
        lineno: int,
        column_offset: int,
        statement: ast.Node,
    ) -> None:
        """Check partition spec."""
        ...

    def visit_PartitionSpec(
        self,
        ancestors: ast.Node,
        node: ast.PartitionSpec,
    ) -> None:
        """Visit PartitionSpec."""
        statement: linter.Statement = linter.get_statement_details(ancestors)

        self._check_partition_spec(
            partition_spec=ast.PartitionSpec(
                strategy=node.strategy,
                partParams=node.partParams,
            ),
            lineno=statement.location,
            column_offset=linter.get_node_location(node),
            statement=ancestors[statement],
        )


class PartitionStrategiesWhitelisted(_PartitionSpec):
    """Only whitelisted partition strategies are allowed."""

    name = "convention.whitelisted_partition_strategies"
    code = "CVP002"

    is_auto_fixable: bool = False

    partition_strategies_mapping: typing.ClassVar[dict[str, str]] = {
        "l": "list",
        "r": "range",
        "h": "hash",
    }

    def _check_partition_spec(
        self,
        *,
        partition_spec: ast.PartitionSpec,
        lineno: int,
        column_offset: int,
        statement: ast.Node,
    ) -> None:
        """Check partition strategy is whitelisted."""
        if (
            self.config.partition_strategies
            and self.partition_strategies_mapping[partition_spec.strategy]
            not in self.config.partition_strategies
        ):

            self.violations.append(
                linter.Violation(
                    lineno=lineno,
                    column_offset=column_offset,
                    statement=statement,
                    description=f"Partitioning strategy '{self.partition_strategies_mapping[partition_spec.strategy]}' is not whitelisted",  # noqa: E501
                ),
            )


class PreferPartitioningByOneKey(_PartitionSpec):
    """Prefer partitioning by one key."""

    name = "convention.prefer_partitioning_by_one_key"
    code = "CVP003"

    is_auto_fixable: bool = False

    def _check_partition_spec(
        self,
        *,
        partition_spec: ast.PartitionSpec,
        lineno: int,
        column_offset: int,
        statement: ast.Node,
    ) -> None:
        """Check partition strategy is whitelisted."""
        if len(partition_spec.partParams) > 1:

            self.violations.append(
                linter.Violation(
                    lineno=lineno,
                    column_offset=column_offset,
                    statement=statement,
                    description="Prefer partitioning by one key",
                ),
            )
